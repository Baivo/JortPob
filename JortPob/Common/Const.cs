using SoulsFormats;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Numerics;
using System.Text;
using System.Threading.Tasks;

namespace JortPob.Common
{
    public static class Const
    {
        #region Paths
        public static string MORROWIND_PATH = Settable.Get("MORROWIND_PATH");
        public static string OUTPUT_PATH = Settable.Get("OUTPUT_PATH");
        public static string CACHE_PATH = $"{OUTPUT_PATH}cache\\";
        #endregion

        #region Optimization
        public static readonly int THREAD_COUNT = int.Parse(Settable.Get("THREAD_COUNT"));
        #endregion

        #region General
        public static readonly float GLOBAL_SCALE = 0.01f;
        public static readonly int CELL_EXTERIOR_BOUNDS = 30;
        public static readonly float CELL_SIZE = 8192f * GLOBAL_SCALE;
        public static readonly float TILE_SIZE = 256f;
        public static readonly int CELL_GRID_SIZE = 64;    // terrain vertices

        public static readonly float TERRAIN_UV_SCALE = 20f;  // uv scale for terrain textures
        public static readonly int TERRAIN_COLOR_OVERLAY_SIZE = 256;  // size of texture generated for vertex color overlay on terrain meshes
        public static readonly string TERRAIN_DEFAULT_TEXTURE = @"Data Files\textures\_land_default.dds";  // morrowind has a default terrain texture that is hardcoded to the exe. id = 65535
        public static readonly LOD_VALUE[] TERRAIN_LOD_VALUES = new LOD_VALUE[]
        {
            new LOD_VALUE(0, FLVER2.FaceSet.FSFlags.None, 1, 512),
            new LOD_VALUE(1, FLVER2.FaceSet.FSFlags.LodLevel1, 4, 1024),
            new LOD_VALUE(2, FLVER2.FaceSet.FSFlags.LodLevel2, 16, 99999),
        };

        /* values are [0] = size of the asset model (calculated by radius and stored in modelinfo) [1] = distance it's visible via partsdrawparam. [2] = fade out range */
        public static readonly List<float[]> ASSET_LOD_VALUES = new()
        {
            new float[] {1f, 32f, 4f},
            new float[] {3f, 64f, 8f},
            new float[] {7f, 128f, 16f},
            new float[] {14f, 256f, 32f},
            new float[] {22f, 512f, 64f},
            new float[] {99999f, 99999f, 0f},
        };

        /* Calculated... ESM lowest cell is [-20,-20]~ on the grid. MSB lowest value is [+33,+40]~. Offset so they overlap */
        public static readonly Vector3 LAYOUT_COORDINATE_OFFSET = new((20*CELL_SIZE)+(35*TILE_SIZE), 0, (20*CELL_SIZE)+(38*TILE_SIZE));

        public static int CHUNK_PARTITION_SIZE = 6;

        public static readonly float CONTENT_SIZE_BIG = 7f;
        public static readonly float CONTENT_SIZE_HUGE = 20f;

        public static readonly int ASSET_BAKE_SCALE_CUTOFF = 5;  // how many assets need a scale before we bake it into a prescaled asset. otherwise dynamic scale is used
        public static readonly int DYNAMIC_ASSET = -1;

        public static readonly int ASSET_GROUP = 900;         // asset folder starting id for generated assets EX: "aeg900_xxx"
        public static readonly int WATER_ASSET_GROUP = 910;   // asset folder id for stuff generated by the watermanager
        public static readonly short PART_DRAW_PARAM = 9000;    // param row starting id for this type of param

        public static readonly float WATER_HEIGHT = 0f;  // used to build water. primarily, if a collision triangle is under this value it becomes the water material
        public static readonly int WATER_RADIUS = 30;   // when we generate water squares, we generate a circle of cells this size. 30 means 30 CELLS of water not 30 units
        public static readonly int WATER_TESSELATION = 1; // number of times to subdivide squares for water
        #endregion

        #region Debug
        /* when building for release everything in this group should be FALSE or NULL */
        public static readonly string DEBUG_EXCLUSIVE_CELL_BUILD_BY_NAME = null; // set to "null" to build entire map.
        public static readonly int[] DEBUG_EXCLUSIVE_BUILD_BY_BOX = null; //new int[] {-5, -10, 0, -5 }; // also set to null to build entire map. format x1, y1, x2, y2. smaller values first, 1 = 1 cell, use cell coordinates
        public static readonly bool DEBUG_SKIP_TERRAIN_BORDER_BLENDING = false; // big speedup on builds, allows multithreading of landscape processing, but makes terrain borders very ugly
        public static readonly bool DEBUG_SKIP_INTERIOR = true;
        public static readonly string DEBUG_PRINT_LOCATION_INFO = null; // set to null if you don't need it. prints msb name of a named location at build done
        public static readonly bool DEBUG_HKX_FORCE_BINARY = true;   // if true we build hkx to binary instead of xml. binary is worse inengine but smithbox cant read xml so guuh
        #endregion




        /* Some ugly cocks */
        public struct LOD_VALUE
        {
            public readonly FLVER2.FaceSet.FSFlags FLAG;
            public readonly int INDEX, DIVISOR;
            public readonly float DISTANCE;
            public LOD_VALUE(int index, FLVER2.FaceSet.FSFlags flag, int divisor, float distance)
            {
                INDEX = index;
                FLAG = flag;
                DIVISOR = divisor;
                DISTANCE = distance;
            }
        }
    }
}
